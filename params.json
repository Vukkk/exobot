{
  "name": "Exobot",
  "tagline": "a chatbot",
  "body": "# Exobot\r\n\r\nAn ES6+ chatbot. Requires Node ^6.2.\r\n\r\n\r\n\r\n## Installation\r\n\r\n* `npm install --save @exoplay/exobot`\r\n\r\n\r\n\r\n## A Brief Example\r\n\r\nTo start an exobot instance, you need to import the bot itself and initialize it\r\nwith plugins and chat service adapters.\r\n\r\n```javascript\r\nconst { Exobot, adapters, plugins, LogLevels } = require('@exoplay/exobot');\r\nconst { Help, Greetings } = plugins;\r\n\r\nconst BOT_ALIAS = '!e';\r\nconst BOT_NAME = 'exobot';\r\nconst LOG_LEVEL = process.env.EXOBOT_LOG_LEVEL || LogLevels.INFO;\r\n\r\nconst shell = adapters.Shell;\r\n\r\nconst bot = new Exobot(BOT_NAME, {\r\n  alias: BOT_ALIAS,\r\n  adapters: [\r\n    new shell(),\r\n  ],\r\n  plugins: [\r\n    new Help(),\r\n    new Greetings(),\r\n  ],\r\n  logLevel: LOG_LEVEL,\r\n});\r\n\r\nmodule.exports = bot;\r\n```\r\n\r\n```\r\n$ node index.js\r\n> Chat: hi, exobot\r\n> exobot: hi, shell!\r\n```\r\n\r\n\r\nWhat did we do there?\r\n\r\n* Created a file named `index.js`\r\n* Imported the `Exobot` class, service adapters, and plugins\r\n* Initialized a new bot, passing in its name, configured service adapters and\r\n  plugins\r\n* Started the bot\r\n* Ran `node index.js` and interacted with the bot\r\n\r\n\r\n\r\n## Getting started\r\n\r\nThe easiest way to start is copy the example above - this will get you started\r\nwith a chatbot with a shell adapter. The shell adapter will start an\r\ninteractive console with which you can chat in a single \"room\"; Exobot will\r\nrespond to messages that trigger plugins.\r\n\r\n1. Make a directory somewhere that you want to keep your bot's configuration\r\n  code.\r\n2. Run `git init` (or source control initialization method of choice), then\r\n  `npm init` to start up an NPM package. (You probably won't publish your bot\r\n  as its own package - but this will create a `package.json` file that contains\r\n  your dependencies.)\r\n3. Run `npm install --save @exoplay/exobot` to install the chatbot.\r\n4. Copy the example above to `index.js`.\r\n5. Run `node index.js`. Chat with yourself for a while, then read on to learn\r\n  how to configure your chatbot, or even build your own plugins and adapters.\r\n\r\n\r\n\r\n## Configuration\r\n\r\nExobot is configured in its constructor, which takes two arguments - a bot\r\nname (a required string), and an options object.\r\n\r\nThe bot name is used for commands - if your bot's name is `'exobot'`, it will\r\n`respond` to commands beginning with `'exobot'`. You'll want this to match the\r\nname used in your chat service (so if its name is actually `'DEATHBOT_9000'` in\r\nSlack, you should call it that here too, or people may be confused.) \r\n\r\nThe options object contains all other configuration - such as a list of\r\nplugins and chat service adapters, log levels, and data encryption keys.\r\n\r\n* `alias` - an additional way to trigger exobot commands. `'/'`, `';'`, or\r\n  `'hey bot'`, for example.\r\n* `adapters` - an array of initialized chat adapters, such as\r\n  [slack](https://github.com/exoplay/exobot-adapter-slack),\r\n  [discord](https://github.com/exoplay/exobot-adapter-discord),\r\n  or [twitch](https://github.com/exoplay/exobot-adapter-twitch). exobot\r\n  also comes with a `shell` adapter for playing around in your terminal.\r\n* `plugins` - an array of initialized plugins, such as \r\n  [giphy](https://github.com/exoplay/exobot-plugin-giphy) or\r\n  [points](https://github.com/exoplay/exobot-plugin-points). exobot also\r\n  comes with `help` and `greetings` plugins as examples.\r\n* `readFile` and `writeFile` - functions called when the in-memory json db\r\n  is saved. By default, this writes a json file to `cwd/data/botname.json`,\r\n  but you could also override the default local file storage to use s3 with\r\n  [exobot-db-s3](https://github.com/exoplay/exobot-db-s3).\r\n* `dbPath` - if you're using local file storage, you can set where to save.\r\n  Defaults to `cwd/data/botname.json`.\r\n\r\n\r\n\r\n## Building plugins\r\n\r\nMost plugins respond to chat messages - either by `listen`ing to _all_ chat\r\nmessages, or `respond`ing to specific commands. exobot comes with `greetings`\r\nand `help` plugins, but building your own is easy. Some examples:\r\n\r\n* [giphy, for gif search](https://github.com/exoplay/exobot-plugin-giphy)\r\n* [points, for fun](https://github.com/exoplay/exobot-plugin-points)\r\n\r\n### An Example Plugin\r\n\r\n```javascript\r\nimport { ChatPlugin } from '@exoplay/exobot';\r\n\r\nexport default class Ping extends ChatPlugin {\r\n  help = 'Says \"pong\" when you send it \"ping\"';\r\n\r\n  register (bot) {\r\n    this.respond(/ping/, this.pong);\r\n  }\r\n\r\n  pong (match, message) {\r\n    return 'pong';\r\n  }\r\n}\r\n```\r\n\r\nIn this plugin, we have extended exobot's ChatPlugin class - this gives it\r\nfunctionality to respond to chat messages. We've then told it to `respond` to\r\nthe regex `/ping/` by firing a function, called `pong`. The `return` value of\r\nthe function is then sent back to the chat channel.\r\n\r\n### A Detailed Anatomy of a Chat Plugin\r\n\r\nChat plugins follow the following lifecycle:\r\n\r\nFirst, The `constructor` is called with options sent in. As the bot is\r\ninitialized with _instances_ of plugins, this is where you would pass in\r\nconfiguration options, such as:\r\n\r\n```javascript\r\nclass StatusPlugin extends ChatPlugin {\r\n  constructor (options) {\r\n    super(options);\r\n    this.endpoint = options.endpoint;\r\n  }\r\n\r\n  //...\r\n\r\n  async getStatus () {\r\n    const res = await this.http.get(this.endpoint);\r\n    return res.statusCode;\r\n  }\r\n}\r\n```\r\n\r\nIn the above example, we'd initialize the exobot instance with\r\n`plugins: [ new StatsPlugin({ endpoint: 'https://github.com' }) ]` to pass\r\nin the options we need later on.\r\n\r\nNext, when the bot instance begins listening, the plugin's `register` method is\r\ncalled, with the `bot` instace passed in. Note that the constructor doesn't have\r\nthe bot yet - it doesn't exist until `register`.\r\n\r\n`register` is also where you register `listen` and `respond` commands. `listen`\r\nand `respond` are the most important parts of your chat plugin - these allow the\r\nbot to interact with chat. Each can take either a regex _or_ a function, and if\r\na match is found (or, if a function, if it is truthy), it will fire the\r\nfunction passed in. Functions for responding can be promises (or\r\nES7 `async` functions) and will resolve when the promises do. This makes it\r\neasy to write asynchronous code, such as firing http requests.\r\n\r\nThe responding function gets two arguments: a `match` object, which is either\r\nthe regex's `exec` response or the function return value, and a `Message`\r\nobject, which contains the original message, user, and whether the message is a\r\nwhisper.\r\n\r\nYou can optionally add a `help` property, which exobot's `help` plugin uses to\r\nexplain to useres how the plugin works.\r\n\r\nFinally, the bot also exposes `bot.http`, which is a promise-ified\r\n[superagent](https://visionmedia.github.io/superagent/) wrapper, to make http\r\ncalls easy to make.\r\n\r\n```javascript\r\nclass StatusPlugin extends ChatPlugin {\r\n  help = [\r\n    'Get the status of an http endpoint. Responds to `status` or listens to',\r\n    'status <http://whatever.com>.'\r\n  ].join('\\n');\r\n\r\n  constructor (options) {\r\n    super(options);\r\n    this.endpoint = options.endpoint;\r\n  }\r\n\r\n  register (bot) {\r\n    super.register(bot);\r\n\r\n    if (!this.endpoint) {\r\n      bot.log.warn('No endpoint passed in to StatusPlugin.');\r\n    }\r\n\r\n    this.respond(/status/, this.getStatus);\r\n    this.listen(/^status (http:\\/\\/\\S+)/, this.getStatus);\r\n\r\n    this.listen(m => m.text === 'status', this.getStatus);\r\n  }\r\n\r\n  async getStatus (match, message) {\r\n    let endpoint = this.endpoint;\r\n\r\n    // if the regex succeeded, match[1] should be an http endpoint\r\n    if (match && match.length) {\r\n      endpoint = match[1];\r\n    }\r\n\r\n    const res = await this.http.get(this.endpoint);\r\n    return res.statusCode;\r\n  }\r\n}\r\n```\r\n\r\nYou can also build other types of plugins: `EventPlugin`, `HTTPPlugin`, or build\r\nyour own class of plugin with the `Plugin` class. Documentation to come someday.\r\n\r\n\r\n\r\n## Building Adapters\r\n\r\nAdapters allow your bot to connect to a chat service, such as Slack or Discord.\r\nexobot comes with a shell adapter by default, but you could also build your own\r\nfor your chat service of choice. Some examples:\r\n\r\n* [slack](https://github.com/exoplay/exobot-adapter-slack)\r\n* [discord](https://github.com/exoplay/exobot-adapter-discord)\r\n* [twitch](https://github.com/exoplay/exobot-adapter-twitch)\r\n\r\n### An Example Adapter\r\n\r\n```javascript\r\n// An example: import an API lib for your chat service, or do it with raw\r\n// sockets or http, or whatever.\r\nimport ChatServiceLibrary from '@chatservice/lib';\r\nimport { Adapter, User } from '@exoplay/exobot';\r\n\r\nexport default class ChatServiceAdapter extends Adapter {\r\n  constructor ({ token, username }) {\r\n    super(...arguments);\r\n    this.token = token;\r\n    this.username = username;\r\n  }\r\n\r\n  register (bot) {\r\n    super.register(bot);\r\n    // Initialize the chat service lib we pulled in earlier\r\n    this.service = new ChatServiceLibrary(this.username, this.token);\r\n\r\n    // listen to some events. bind the functions to `this` to make sure we can\r\n    // access our class instance, bot, and `super`.\r\n    this.service.on('ready', this.serviceReady.bind(this));\r\n    this.service.on('message', this.serviceMessage.bind(this));\r\n  }\r\n\r\n  // the `send` funciton is defined by Adapter and called by plugins when they\r\n  // resolve (if they resolve.)\r\n  send (message) {\r\n    this.bot.log.debug(`Sending ${message.text} to ${message.channel}`);\r\n\r\n    // Send the message data to the chat service client.\r\n    this.service.sendMessage({\r\n      to: message.channel,\r\n      message: message.text,\r\n    });\r\n  }\r\n\r\n  serviceReady () {\r\n    this.status = Adapter.STATUS.CONNECTED;\r\n    this.bot.emitter.emit('connected', this.id);\r\n    this.bot.log.notice('Connected to ChatService.');\r\n  }\r\n\r\n  // We'll pretend our fake chat service lib takes a function which is called\r\n  // with message, user, and channel. We'll take these arguments and \"receive\"\r\n  // them, which will fire off all of the plugins so they can respond where\r\n  // necessary.\r\n  serviceMessage (user, text, channel) {\r\n    // We don't want to listen to messages from ourself.\r\n    if (user.name === this.username) { return; }\r\n\r\n    // Create a new User instance to pass along in the Message.\r\n    const user = new User(user.name, user.id);\r\n\r\n    // Check if our fake chat service lib says the channel is \"private\". If it\r\n    // is a private message between the user and bot, we'll make it act like a\r\n    // \"respond\" command instead of just a \"listen\".\r\n    if (channel.private) {\r\n      return super.receiveWhisper({ user, text, channel });\r\n    }\r\n\r\n    return this.receive({ user, text, channel });\r\n  }\r\n}\r\n\r\n```\r\n\r\n### A Detailed Anatomy of a Chat Service Adapter\r\n\r\nChat service adapters have a similar lifecycle to plugins:\r\n\r\n1. Constructor, before the bot is initialized;\r\n2. Register, when the bot is initialized, where you first get acccess to the\r\n  exobot instance, and where you listen to your chat service;\r\n3. Functions called by events fired by the chat service;\r\n4. Finally, `send`, called by the bot instance when plugins resolve.\r\n\r\nYou can listen and fire any arbitrary functions - for example, some chat\r\nservices may include presence information, and fire `enter` and `leave` events.\r\nYou can then `receive` your own `PresenceMessage` similar to how we `receive` a\r\n`TextMessage` in the `serviceMessage` in the example. (Right now, the only\r\n`Message` classes are `TextMessage` and `PresenceMessage`). Many adapters may\r\nalso want to make use of the `Status` enum, which could be:\r\n\r\n* UNINITIALIZED\r\n* CONNECTING\r\n* CONNECTED\r\n* DISCONNECTED\r\n* RECONNECTING\r\n* ERROR\r\n\r\nYou may also want to use `bot.log` to log important events to stdout, such as\r\nconnection or configuration errors. `bot.log` can fire:\r\n\r\n* debug\r\n* info\r\n* notice\r\n* warning\r\n* error\r\n* critical\r\n* alert\r\n* emergency\r\n\r\nIn order of ascending severity.\r\n\r\n\r\n## Acknowledgements\r\n\r\nExobot is loosely based on [hubot](https://github.com/github/hubot), for which\r\nthe author has a great deal of admiration. Hubot is more user-friendly in many\r\nways (autoloading scripts, for example, instead of requiring the user to write\r\ntheir own imports and configuration). In other ways, this flexibility can be\r\nlimiting; it's easier to make a pure-js bot more efficient and testable (and\r\nthe author thinks that ES6, rather than Coffeescript, is a more viable choice\r\nof language; plugin-writers can always choose to opt-in to Coffeescript and\r\nexport a built file if they want.)\r\n\r\n\r\n\r\n## License\r\n\r\nLGPL licensed. Copyright 2016 Exoplay, LLC. See LICENSE file for more details.\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}